#
# Autogenerated by Thrift Compiler (0.9.3)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class ImageSourceType:
  """
  Enumerations
  """
  IMAGE = 0
  VIDEO = 1
  DEVICE = 2
  STREAM = 3

  _VALUES_TO_NAMES = {
    0: "IMAGE",
    1: "VIDEO",
    2: "DEVICE",
    3: "STREAM",
  }

  _NAMES_TO_VALUES = {
    "IMAGE": 0,
    "VIDEO": 1,
    "DEVICE": 2,
    "STREAM": 3,
  }

class FilterSourceType:
  RGB = 0
  BGR = 1
  HSV = 2
  HSL = 3
  BINARY = 4

  _VALUES_TO_NAMES = {
    0: "RGB",
    1: "BGR",
    2: "HSV",
    3: "HSL",
    4: "BINARY",
  }

  _NAMES_TO_VALUES = {
    "RGB": 0,
    "BGR": 1,
    "HSV": 2,
    "HSL": 3,
    "BINARY": 4,
  }

class FilterSinkType:
  RGB = 0
  BGR = 1
  HSV = 2
  HSL = 3
  BINARY = 4
  MAP = 5
  INPUT = 6

  _VALUES_TO_NAMES = {
    0: "RGB",
    1: "BGR",
    2: "HSV",
    3: "HSL",
    4: "BINARY",
    5: "MAP",
    6: "INPUT",
  }

  _NAMES_TO_VALUES = {
    "RGB": 0,
    "BGR": 1,
    "HSV": 2,
    "HSL": 3,
    "BINARY": 4,
    "MAP": 5,
    "INPUT": 6,
  }


class SourceNotFound(TException):
  """
  Exceptions

  Attributes:
   - path
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'path', None, None, ), # 1
  )

  def __init__(self, path=None,):
    self.path = path

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.path = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SourceNotFound')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 1)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.path)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InputSource:
  """
  Structures

  Attributes:
   - source
   - path
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'source', None, None, ), # 1
    (2, TType.STRING, 'path', None, None, ), # 2
  )

  def __init__(self, source=None, path=None,):
    self.source = source
    self.path = path

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.source = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.path = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InputSource')
    if self.source is not None:
      oprot.writeFieldBegin('source', TType.I32, 1)
      oprot.writeI32(self.source)
      oprot.writeFieldEnd()
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 2)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.source is None:
      raise TProtocol.TProtocolException(message='Required field source is unset!')
    if self.path is None:
      raise TProtocol.TProtocolException(message='Required field path is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.source)
    value = (value * 31) ^ hash(self.path)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Output:
  """
  Attributes:
   - imagePath
   - data
   - computeTime
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'imagePath', None, None, ), # 1
    (2, TType.MAP, 'data', (TType.STRING,None,TType.DOUBLE,None), None, ), # 2
    (3, TType.DOUBLE, 'computeTime', None, None, ), # 3
  )

  def __init__(self, imagePath=None, data=None, computeTime=None,):
    self.imagePath = imagePath
    self.data = data
    self.computeTime = computeTime

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.imagePath = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.data = {}
          (_ktype1, _vtype2, _size0 ) = iprot.readMapBegin()
          for _i4 in xrange(_size0):
            _key5 = iprot.readString()
            _val6 = iprot.readDouble()
            self.data[_key5] = _val6
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.DOUBLE:
          self.computeTime = iprot.readDouble()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Output')
    if self.imagePath is not None:
      oprot.writeFieldBegin('imagePath', TType.STRING, 1)
      oprot.writeString(self.imagePath)
      oprot.writeFieldEnd()
    if self.data is not None:
      oprot.writeFieldBegin('data', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.DOUBLE, len(self.data))
      for kiter7,viter8 in self.data.items():
        oprot.writeString(kiter7)
        oprot.writeDouble(viter8)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.computeTime is not None:
      oprot.writeFieldBegin('computeTime', TType.DOUBLE, 3)
      oprot.writeDouble(self.computeTime)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.imagePath)
    value = (value * 31) ^ hash(self.data)
    value = (value * 31) ^ hash(self.computeTime)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Filter:
  """
  Attributes:
   - sourceType
   - sinkType
   - filter
   - params
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sourceType', None, None, ), # 1
    (2, TType.I32, 'sinkType', None, None, ), # 2
    (3, TType.STRING, 'filter', None, None, ), # 3
    (4, TType.MAP, 'params', (TType.STRING,None,TType.DOUBLE,None), None, ), # 4
  )

  def __init__(self, sourceType=None, sinkType=None, filter=None, params=None,):
    self.sourceType = sourceType
    self.sinkType = sinkType
    self.filter = filter
    self.params = params

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sourceType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.sinkType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.filter = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.params = {}
          (_ktype10, _vtype11, _size9 ) = iprot.readMapBegin()
          for _i13 in xrange(_size9):
            _key14 = iprot.readString()
            _val15 = iprot.readDouble()
            self.params[_key14] = _val15
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Filter')
    if self.sourceType is not None:
      oprot.writeFieldBegin('sourceType', TType.I32, 1)
      oprot.writeI32(self.sourceType)
      oprot.writeFieldEnd()
    if self.sinkType is not None:
      oprot.writeFieldBegin('sinkType', TType.I32, 2)
      oprot.writeI32(self.sinkType)
      oprot.writeFieldEnd()
    if self.filter is not None:
      oprot.writeFieldBegin('filter', TType.STRING, 3)
      oprot.writeString(self.filter)
      oprot.writeFieldEnd()
    if self.params is not None:
      oprot.writeFieldBegin('params', TType.MAP, 4)
      oprot.writeMapBegin(TType.STRING, TType.DOUBLE, len(self.params))
      for kiter16,viter17 in self.params.items():
        oprot.writeString(kiter16)
        oprot.writeDouble(viter17)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.sourceType is None:
      raise TProtocol.TProtocolException(message='Required field sourceType is unset!')
    if self.sinkType is None:
      raise TProtocol.TProtocolException(message='Required field sinkType is unset!')
    if self.filter is None:
      raise TProtocol.TProtocolException(message='Required field filter is unset!')
    if self.params is None:
      raise TProtocol.TProtocolException(message='Required field params is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sourceType)
    value = (value * 31) ^ hash(self.sinkType)
    value = (value * 31) ^ hash(self.filter)
    value = (value * 31) ^ hash(self.params)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Resolution:
  """
  Attributes:
   - horizontal
   - vertical
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'horizontal', None, None, ), # 1
    (2, TType.I32, 'vertical', None, None, ), # 2
  )

  def __init__(self, horizontal=None, vertical=None,):
    self.horizontal = horizontal
    self.vertical = vertical

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.horizontal = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.vertical = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Resolution')
    if self.horizontal is not None:
      oprot.writeFieldBegin('horizontal', TType.I32, 1)
      oprot.writeI32(self.horizontal)
      oprot.writeFieldEnd()
    if self.vertical is not None:
      oprot.writeFieldBegin('vertical', TType.I32, 2)
      oprot.writeI32(self.vertical)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.horizontal is None:
      raise TProtocol.TProtocolException(message='Required field horizontal is unset!')
    if self.vertical is None:
      raise TProtocol.TProtocolException(message='Required field vertical is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.horizontal)
    value = (value * 31) ^ hash(self.vertical)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Camera:
  """
  Attributes:
   - deviceName
   - resolution
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'deviceName', None, None, ), # 1
    None, # 2
    None, # 3
    None, # 4
    None, # 5
    None, # 6
    None, # 7
    None, # 8
    None, # 9
    (10, TType.STRUCT, 'resolution', (Resolution, Resolution.thrift_spec), None, ), # 10
  )

  def __init__(self, deviceName=None, resolution=None,):
    self.deviceName = deviceName
    self.resolution = resolution

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.deviceName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.resolution = Resolution()
          self.resolution.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Camera')
    if self.deviceName is not None:
      oprot.writeFieldBegin('deviceName', TType.STRING, 1)
      oprot.writeString(self.deviceName)
      oprot.writeFieldEnd()
    if self.resolution is not None:
      oprot.writeFieldBegin('resolution', TType.STRUCT, 10)
      self.resolution.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.deviceName is None:
      raise TProtocol.TProtocolException(message='Required field deviceName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.deviceName)
    value = (value * 31) ^ hash(self.resolution)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
